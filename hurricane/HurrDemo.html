<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Hurricane Demo</title>
    <link rel="stylesheet" type="text/css" href="../css/gfx-scene.css" />
    <!-- Set the viewport size to the screen size, so it will be displayed maximized, but unscaled. -->
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1"/>

    <!-- Include several libraries from THREE.js and the Scene class  -->
    <script src="../three-js/three.js"></script>
    <script src="../three-js/Detector.js"></script>
    <script src="../three-js/stats.js"></script>
    <script src="../three-js/dat.gui.js"></script>
    <script src="../gfx/OrbitControls-Touch-Ortho.js"></script>
    <script src="../gfx/math-ext.js"></script>
    <script src="../gfx/HttpStatus.js"></script>
    <script src="../gfx/gfx-scene.js"></script>
    <script src="../gfx/Julian.js"></script>
    <script src="../gfx/Carto.js"></script>
    <script src="../gfx/arc.js"></script>
    <script src="../gfx/GreatCircle.js"></script>
    <script src="MetParm.js"></script>
    <script src="StormParm.js"></script>
    <script src="StormFile.js"></script>
    <script src="HurrModel.js"></script>
</head>
<body>

<script>
    var hurrModel = undefined;
    var stormFile = new StormFile.StormFile();
    var curStorm  = undefined;
    var years = undefined;
    var storms = undefined;
    var stormLabels = undefined;
    var entryLabels = undefined;
    var options = undefined;

    // allocate the Scene object, request orbitControls, some of 3D axes 10 units high and the stats
    var gfxScene = new GFX.Scene( {
        cameraPos : [4, 3, 4],
        controls:true,
        datgui:true,
        guiWidth:500,
        displayStats:true});

    testArc();

    // then initialize our demo's stuff
    initializeDemo();

    // temporary...
    animateScene();

    function testArc() {
        var start = { x: -122, y: 48 };
        var end   = { x: -77, y: 39 };
        var startLL = { lat: 48, lon: -122 };
        var endLL = { lat: 39, lon: -77 };

        var generator = new arc.GreatCircle(start, end, {'name': 'Seattle to DC'});

        var line = generator.Arc(100,{offset:10});

        var lineJSON = line.json();
        var lineWKT  = line.wkt();

        var gcGen = new GreatCircle( startLL, endLL, {'name': 'Seattle to DC'});

        var points = gcGen.generateArc(100, { offset:10 });
    }

    /**
     * Initialize the Demo.
     */
    function initializeDemo() {

        // Create the mesh onto which we will render the output of the hurricane model
        createGlobe();

        // now create the model.  It doesn't have any parameters or data - it's
        // just the executable model itself
        hurrModel = new HurrModel.HurrModel({

            renderFunc: renderFunc
        });

        loadStorms( stormReady );
    }

    function loadStorms() {

        stormFile = new StormFile.StormFile();
        //stormFile.loadData( "hurrdata.json", stormReady );
        stormFile.loadData( "hurdat2-1851-2016-041117.json", stormReady );
    }

    function stormReady() {

        curStorm = stormFile.getJSON();

        setupDatGui();
    }

    function runStorm() {
        hurrModel.initArrays();
        hurrModel.initialise();

        // Start the animation
        animateScene();
    }

    function createGlobe () {
        var globe = new THREE.SphereGeometry(2, 32, 32);

        var textureLoader = new THREE.TextureLoader();
        var mat = new THREE.MeshPhongMaterial({ color: '#ffffff' });
        textureLoader.load( "images/8081-earthmap4k.jpg", function( texture ) {
            mat.map = texture;
            mat.needsUpdate = true;

            var mesh = new THREE.Mesh(globe, mat);
            gfxScene.add(mesh);
        } );
    }

    /**
     * Update the existing controller for storms and create a new one.
     * Have to do it this way as there appears to be no easy way to
     * "refresh" the data in a controller
     */
    function updateStorms ( options, year ) {

        if ( updateStorms.gui !== undefined )
            gfxScene.gui.remove( updateStorms.gui );

        storms = stormFile.getStormsForYear( Number(year) );
        stormLabels = stormFile.getStormLabels(storms);
        options.stormLabels = stormLabels[0];

        updateStorms.gui = gfxScene.gui.add(options, "stormLabels", stormLabels ).name("Storms");
        updateStorms.gui.onChange( stormsChange );
    }

    /**
     * Handle the change event for the storms controller
     */
    function stormsChange() {
        var index = stormLabels.indexOf(options.stormLabels);
        curStorm = storms[index];
        updateEntries( options, curStorm);
    }

    /**
     * Update existing controller for the entries and create a new one
     */
    function updateEntries ( options, storm ) {
        if ( updateEntries.gui !== undefined )
            gfxScene.gui.remove( updateEntries.gui );

        entryLabels = stormFile.getEntryLabels( storm );
        options.entryLabels = entryLabels[0];

        updateEntries.gui = gfxScene.gui.add(options, "entryLabels", entryLabels ).name("Entries");
        updateEntries.gui.onChange( entriesChange );
    }

    /**
     * Handle the change event for the entries controller.  Not used yet.
     */
    function entriesChange() {
        var index = entryLabels.indexOf(options.entryLabels);
    }

    /**
     * Set up the datgui controls on the basis of the loaded storm data
     */
    function setupDatGui() {

        years = stormFile.getYears();
        storms = stormFile.getStormsForYear(years[0]);
        stormLabels = stormFile.getStormLabels(storms);
        entryLabels = stormFile.getEntryLabels( storms[0] );

        options = {};
        options.year = years[0];
        options.stormLabels = stormLabels[0];
        options.entryLabels = entryLabels[0];

        var gui_year = gfxScene.gui.add(options, "year", years ).name("Year").onChange(function() {
            console.log("Changed year");
            updateStorms( options, options.year );
            updateEntries( options, storms[0]);
        });

        updateStorms( options, options.year );
        updateEntries( options, storms[0]);
    }

    /**
     * Called by the hurricane model to have the sample data rendered
     * In this case, the wind arrows and eye are already in existence
     * so we just update the location of the eye and set the direction
     * and scale of the arrows
     */
    function renderFunc ( eyex, eyeY, sampleData ) {

    }

    /**
     * Animate the scene and call rendering.
     */
    function animateScene() {

        // Tell the browser to call this function when page is visible
        requestAnimationFrame(animateScene);

        // tell the hurricane model to update itself and call back to render when it can
        //hurrModel.timeStep();

        // Map the 3D scene down to the 2D screen (render the frame)
        gfxScene.renderScene();
    }
</script>

</body>
</html>