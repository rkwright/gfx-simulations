<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Hurricane Demo</title>
    <link rel="stylesheet" type="text/css" href="../css/gfx-scene.css" />
    <!-- Set the viewport size to the screen size, so it will be displayed maximized, but unscaled. -->
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1"/>

    <!-- Include several libraries from THREE.js and the Scene class  -->
    <script src="../three-js/three.js"></script>
    <script src="../three-js/Detector.js"></script>
    <script src="../three-js/stats.js"></script>
    <script src="../three-js/dat.gui.js"></script>
    <script src="../gfx/OrbitControls-Touch-Ortho.js"></script>
    <script src="../gfx/math-ext.js"></script>
    <script src="../gfx/HttpStatus.js"></script>
    <script src="../gfx/gfx-scene.js"></script>
    <script src="../gfx/Julian.js"></script>
    <script src="../gfx/Carto.js"></script>
    <script src="../gfx/GreatCircle.js"></script>
    <script src="MetParm.js"></script>
    <script src="StormParm.js"></script>
    <script src="StormData.js"></script>
    <script src="StormFile.js"></script>
    <script src="HurrModel.js"></script>
</head>
<body>

<script>
    var TRACK_DIA   = 0.005;
    var hurrModel   = undefined;
    var stormFile   = new StormFile();
    var curStorm    = undefined;
    var years       = undefined;
    var storms      = undefined;
    var stormLabels = undefined;
    var entryLabels = undefined;
    var options     = undefined;
    var carto = new Carto();
    var saffirMat = [];
    var stormData = new StormData();

    // allocate the Scene object, request orbitControls, some of 3D axes 10 units high and the stats
    var gfxScene = new GFX.Scene( {
        cameraPos : [4, 3, 4],
        controls:true,
        datgui:true,
        guiWidth:500,
        displayStats:true});

    //testArc();

    // then initialize our demo's stuff
    initializeDemo();

    // temporary...
    animateScene();

    function testArc() {
        var startLL = { lat: 48, lon: -122 };
        var endLL = { lat: 39, lon: -77 };

        var gcGen = new GreatCircle();

        var points = gcGen.generateArc( startLL, endLL, 100, { offset:10, 'name': 'Seattle to DC' });
    }

    /**
     * Initialize the Demo.
     */
    function initializeDemo() {

        // Create the mesh onto which we will render the output of the hurricane model
        createGlobe();

        // now create the model.  It doesn't have any parameters or data - it's
        // just the executable model itself
        hurrModel = new HurrModel({

            renderFunc: renderHurricane
        });

        loadStorms( stormReady );

        createSaffirMat();
    }

    /**
     * Load all the storms in the specified file, parsing them into JSON
     */
    function loadStorms() {

        stormFile = new StormFile();
        //stormFile.loadData( "hurrdata.json", stormReady );
        stormFile.loadData( "hurdat2-1851-2016-041117.json", stormReady );
    }

    /**
     * Call back from HTTPRequest when data has been loaded
     */
    function stormReady() {
        setupDatGui();
    }

    /**
     *  Initialize the current model run and kick it off
     */
    function runStorm() {
        hurrModel.initArrays();
        hurrModel.initialise();

        // Start the animation
        animateScene();
    }

    /**
     * Create the sphere mesh and wrap it with the image
     */
    function createGlobe() {
        var globe = new THREE.SphereGeometry(2, 32, 32);

        var textureLoader = new THREE.TextureLoader();
        var bumpLoader = new THREE.TextureLoader();
        var mat = new THREE.MeshPhongMaterial({color: '#ffffff', transparent: true, opacity: 0.75});
        textureLoader.load("images/8081-earthmap4k.jpg", function (texture) {
            mat.map = texture;
            mat.needsUpdate = true;
            textureLoader.load("images/8081-earthbump4k.jpg", function (bump) {
                mat.bumpMap = bump;
                mat.bumpScale = 0.05;


                var mesh = new THREE.Mesh(globe, mat);
                gfxScene.add(mesh);
            });
        });

    }

    function createSaffirMat() {

        for ( var i=0; i<STORMDATA.SAFFIR.length; i++ ) {
            saffirMat[i] = new THREE.MeshLambertMaterial( {color: STORMDATA.SAFFIR[i].color});
        }
    }

    /**
     * Plot the current storm track by fetching the set of positions and creating
     * great-circle arcs for each and creating a curve in threee.js for them.
     *
     * The procedure is:
     * - iterate over the storm track entries
     * - for each pair of points
     * - calculate the great circle arc, which returns an array of lat/lon [n][2]
     * - generate the transform of that array into scaled 3D-space as an array of Vector3
     * - generate a CatMullCurve using three.js
     * - generate a tube geometry using that curve, returns the resulting geometry
     */
    function plotStormTrack() {
        var gcGen = new GreatCircle();
        var points;
        var startLL = { lat: curStorm.entries[0][STORMDATA.LAT], lon: curStorm.entries[0][STORMDATA.LON] };
        var endLL   = {};
        var scale = 2 / CARTO.EARTH_DIAMETER;
        var xyz;

        var saffirCat = stormData.getSaffirCat( curStorm.entries[0][STORMDATA.MAXWIND]);
        var mat =  saffirMat[saffirCat];

        roundJoin( startLL.lat, startLL.lon, scale, mat );

        console.log(" LL: " + startLL.lat + ", " + startLL.lon);

        for ( var i=1; i<curStorm.entries.length; i++ ) {
            endLL = { lat: curStorm.entries[i][STORMDATA.LAT], lon: curStorm.entries[i][STORMDATA.LON] };

            saffirCat = stormData.getSaffirCat( curStorm.entries[i][STORMDATA.MAXWIND]);
            mat =  saffirMat[saffirCat];

            roundJoin( endLL.lat, endLL.lon, scale, mat );

            console.log(" LL: " + endLL.lat + ", " + endLL.lon);

            points = gcGen.generateArc( startLL, endLL, 10, { offset:10 } );

            var pts = points[0];
            var track = [];

            for ( var j=0; j<pts.length; j++ ) {
                xyz = carto.latLonToXYZ( pts[j][1], pts[j][0], CARTO.EARTH_DIAMETER, scale ) ;
                track.push( xyz );
                console.log("xyz: " + xyz.x.toFixed(2) + " " + xyz.y.toFixed(2) + " " + xyz.z.toFixed(2));
            }

            var curve = new THREE.CatmullRomCurve3( track );
            var geometry = new THREE.TubeGeometry( curve, track.length, TRACK_DIA, 32, false );

            var arcMesh = new THREE.Mesh(geometry, mat);
            gfxScene.add( arcMesh );

            startLL = endLL;
        }

    }

    /**
     * Create a sphere to form the "round join" between sections of the track
     */
    function roundJoin( lat, lon, scale, mat ) {
        var join = new THREE.SphereGeometry(TRACK_DIA, 32, 32);

        xyz = carto.latLonToXYZ( lat, lon, CARTO.EARTH_DIAMETER, scale ) ;

        var mesh = new THREE.Mesh(join, mat);
        mesh.position.set(xyz.x, xyz.y, xyz.z);
        gfxScene.add(mesh);
    }

    function getStormLatLon ( storm ) {
        var latLon
    }

    /**
     * Update the existing controller for storms and create a new one.
     * Have to do it this way as there appears to be no easy way to
     * "refresh" the data in a controller
     */
    function updateStorms ( options, year ) {

        if ( updateStorms.gui !== undefined )
            gfxScene.gui.remove( updateStorms.gui );

        storms = stormFile.getStormsForYear( Number(year) );
        stormLabels = stormFile.getStormLabels(storms);
        options.stormLabels = stormLabels[0];

        updateStorms.gui = gfxScene.gui.add(options, "stormLabels", stormLabels ).name("Storms");
        updateStorms.gui.onChange( stormsChange );
    }

    /**
     * Handle the change event for the storms controller
     */
    function stormsChange() {
        var index = stormLabels.indexOf(options.stormLabels);
        curStorm = storms[index];
        updateEntries( options, curStorm);
    }

    /**
     * Update existing controller for the entries and create a new one
     */
    function updateEntries ( options, storm ) {
        if ( updateEntries.gui !== undefined )
            gfxScene.gui.remove( updateEntries.gui );

        entryLabels = stormFile.getEntryLabels( storm );
        options.entryLabels = entryLabels[0];

        updateEntries.gui = gfxScene.gui.add(options, "entryLabels", entryLabels ).name("Entries");
        updateEntries.gui.onChange( entriesChange );
    }

    /**
     * Handle the change event for the entries controller.  Not used yet.
     */
    function entriesChange() {
        var index = entryLabels.indexOf(options.entryLabels);
    }

    /**
     * Set up the datgui controls on the basis of the loaded storm data
     */
    function setupDatGui() {

        years = stormFile.getYears();
        storms = stormFile.getStormsForYear(years[0]);
        stormLabels = stormFile.getStormLabels(storms);
        entryLabels = stormFile.getEntryLabels( storms[0] );

        options = {};
        options.year = years[0];
        options.stormLabels = stormLabels[0];
        options.entryLabels = entryLabels[0];
        options.update = function() {
            plotStormTrack();
        };

        var gui_year = gfxScene.gui.add(options, "year", years ).name("Year").onChange(function() {
            console.log("Changed year");
            updateStorms( options, options.year );
            updateEntries( options, storms[0]);
        });

        updateStorms( options, options.year );

        curStorm = storms[0];
        updateEntries( options, curStorm);

        gfxScene.gui.add( options, 'update' );
    }

    /**
     * Called by the hurricane model to have the sample data rendered
     * In this case, the wind arrows and eye are already in existence
     * so we just update the location of the eye and set the direction
     * and scale of the arrows
     */
    function renderHurricane ( eyex, eyeY, sampleData ) {

    }

    /**
     * Animate the scene and call rendering.
     */
    function animateScene() {

        // Tell the browser to call this function when page is visible
        requestAnimationFrame(animateScene);

        // tell the hurricane model to update itself and call back to render when it can
        //hurrModel.timeStep();

        // Map the 3D scene down to the 2D screen (render the frame)
        gfxScene.renderScene();
    }
</script>

</body>
</html>