<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Hurricane Demo</title>
    <link rel="stylesheet" type="text/css" href="../css/gfx-scene.css" />
    <!-- Set the viewport size to the screen size, so it will be displayed maximized, but unscaled. -->
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1"/>

    <!-- Include several libraries from THREE.js and the Scene class  -->
    <script src="../three-js/three.js"></script>
    <script src="../three-js/Detector.js"></script>
    <script src="../three-js/stats.js"></script>
    <script src="../three-js/dat.gui.min.js"></script>
    <script src="../gfx/OrbitControls-Touch-Ortho.js"></script>
    <script src="../gfx/math-ext.js"></script>
    <script src="../gfx/HttpStatus.js"></script>
    <script src="../gfx/gfx-scene.js"></script>
    <script src="../gfx/Julian.js"></script>
    <script src="../gfx/Carto.js"></script>
    <script src="MetParm.js"></script>
    <script src="StormParm.js"></script>
    <script src="StormFile.js"></script>
    <script src="HurrModel.js"></script>
</head>
<body>

<script>
    var hurrModel = undefined;
    var stormFile = new StormFile.StormFile();
    var curStorm  = undefined;
    //var gui = undefined;

    // allocate the Scene object, request orbitControls, some of 3D axes 10 units high and the stats
    var gfxScene = new GFX.Scene( {
        cameraPos : [4, 3, 4],
        axesHeight:10,
        controls:true,
        datgui:true,
        guiWidth:500,
        displayStats:true});


    // then initialize our demo's stuff
    initializeDemo();

    /**
     * Initialize the Demo.
     */
    function initializeDemo() {

        // Create the mesh onto which we will render the output of the hurricane model
        createGlobe();

        // now create the model.  It doesn't have any parameters or data - it's
        // just the executable model itself
        hurrModel = new HurrModel.HurrModel({

            renderFunc: renderFunc
        });

        loadStorms( stormReady );
    }

    function loadStorms() {

        stormFile = new StormFile.StormFile();
        //stormFile.loadData( "hurrdata.json", stormReady );
        stormFile.loadData( "hurdat2-1851-2016-041117.json", stormReady );
    }

    function stormReady() {

        curStorm = stormFile.getJSON();

        setupDatGui();
    }

    function runStorm() {
        hurrModel.initArrays();
        hurrModel.initialise();

        // Start the animation
        animateScene();
    }

    function createGlobe () {
        var globe = new THREE.SphereGeometry(2, 32, 32);

        var textureLoader = new THREE.TextureLoader();
        var mat = new THREE.MeshPhongMaterial({ color: '#ffffff' });
        textureLoader.load( "images/8081-earthmap4k.jpg", function( texture ) {
            mat.map = texture;
            mat.needsUpdate = true;

            var mesh = new THREE.Mesh(globe, mat);
            gfxScene.add(mesh);
        } );


    }

    /**
     * Set up the datgui controls on the basis of the loaded storm data
     */
    function setupDatGui() {

        var years = stormFile.getYears();
        var storms = stormFile.getStormsForYear( years[0] );
        var stormLabels = stormFile.getStormLabels( storms );
        var entryLabels = stormFile.getEntryLabels( storms[0] );

        var options = [];
        options.year = years[0];
        options.stormLabels = stormLabels[0];
        options.entryLabels = entryLabels[0];

        var gui_year = gfxScene.gui.add(options, "year", years ).onChange(function() {

            storms = stormFile.getStormsForYear(Number(options.year));
            stormLabels = stormFile.getStormLabels(storms);
            gui_storms = gui_storms.options(stormLabels);
            options.stormLabels = stormLabels[0];
            gui_storms.updateDisplay();
        });

        var gui_storms = gfxScene.gui.add(options, "stormLabels", stormLabels ).onChange(function() {

            console.log("Selected storm");

            entryLabels = stormFile.getEntryLabels( storms[0] );
            gui_entries = gui_storms.options(entryLabels);
            options.entryLabels = entryLabels[0];
            gui_entries.updateDisplay();
        });

        var gui_entries = gfxScene.gui.add(options, "entryLabels", entryLabels ).onChange(function() {

            console.log("Entries for storm");
        });

    }

    /**
     * Called by the hurricane model to have the sample data rendered
     * In this case, the wind arrows and eye are already in existence
     * so we just update the location of the eye and set the direction
     * and scale of the arrows
     */
    function renderFunc ( eyex, eyeY, sampleData ) {

    }

    /**
     * Animate the scene and call rendering.
     */
    function animateScene() {

        // Tell the browser to call this function when page is visible
        requestAnimationFrame(animateScene);

        // tell the hurricane model to update itself and call back to render when it can
        //hurrModel.timeStep();

        // Map the 3D scene down to the 2D screen (render the frame)
        gfxScene.renderScene();
    }
</script>

</body>
</html>