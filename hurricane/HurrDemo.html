<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Hurricane Demo</title>
    <link rel="stylesheet" type="text/css" href="../css/gfx-scene.css" />
    <!-- Set the viewport size to the screen size, so it will be displayed maximized, but unscaled. -->
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1"/>

    <!-- Include several libraries from THREE.js and the Scene class  -->
    <script src="../three-js/three.js"></script>
    <script src="../three-js/Detector.js"></script>
    <script src="../three-js/stats.js"></script>
    <script src="../three-js/dat.gui.js"></script>
    <script src="../gfx/OrbitControls-Touch-Ortho.js"></script>
    <script src="../gfx/math-ext.js"></script>
    <script src="../gfx/HttpStatus.js"></script>
    <script src="../gfx/gfx-scene.js"></script>
    <script src="../gfx/Julian.js"></script>
    <script src="../gfx/Carto.js"></script>
    <script src="MetParm.js"></script>
    <script src="StormParm.js"></script>
    <script src="StormFile.js"></script>
    <script src="HurrModel.js"></script>
</head>
<body>

<script>
    var hurrModel = undefined;
    var stormFile = new StormFile.StormFile();
    var curStorm  = undefined;
    var years = undefined;
    var storms = undefined;
    var stormLabels = undefined;
    var entryLabels = undefined;

    //var gui = undefined;

    // allocate the Scene object, request orbitControls, some of 3D axes 10 units high and the stats
    var gfxScene = new GFX.Scene( {
        cameraPos : [4, 3, 4],
        axesHeight:10,
        controls:true,
        datgui:true,
        guiWidth:500,
        displayStats:true});


    // then initialize our demo's stuff
    initializeDemo();

    /**
     * Initialize the Demo.
     */
    function initializeDemo() {

        // Create the mesh onto which we will render the output of the hurricane model
        createGlobe();

        // now create the model.  It doesn't have any parameters or data - it's
        // just the executable model itself
        hurrModel = new HurrModel.HurrModel({

            renderFunc: renderFunc
        });

        loadStorms( stormReady );
    }

    function loadStorms() {

        stormFile = new StormFile.StormFile();
        //stormFile.loadData( "hurrdata.json", stormReady );
        stormFile.loadData( "hurdat2-1851-2016-041117.json", stormReady );
    }

    function stormReady() {

        curStorm = stormFile.getJSON();

        setupDatGui();
    }

    function runStorm() {
        hurrModel.initArrays();
        hurrModel.initialise();

        // Start the animation
        animateScene();
    }

    function createGlobe () {
        var globe = new THREE.SphereGeometry(2, 32, 32);

        var textureLoader = new THREE.TextureLoader();
        var mat = new THREE.MeshPhongMaterial({ color: '#ffffff' });
        textureLoader.load( "images/8081-earthmap4k.jpg", function( texture ) {
            mat.map = texture;
            mat.needsUpdate = true;

            var mesh = new THREE.Mesh(globe, mat);
            gfxScene.add(mesh);
        } );
    }

    /**
     * Remove any existing controller for storms and create a new one.
     */
    function addStormsGui ( controller, options, year ) {

        if ( controller !== undefined )
            gfxScene.gui.remove( controller );

        storms = stormFile.getStormsForYear( Number(year) );
        stormLabels = stormFile.getStormLabels(storms);

        var gui_s = gfxScene.gui.add(options, "stormLabels", stormLabels );
        gui_s.onChange( stormsChange );

        return gui_s;
    }

    function stormsChange() {
        console.log("Selected storm");
    }

    function addEntriesGui ( controller, options, storm ) {
        if ( controller !== undefined )
            gfxScene.gui.remove( controller );

        entryLabels = stormFile.getEntryLabels( storm );
        options.entryLabels = entryLabels[0];

        var gui_e = gfxScene.gui.add(options, "entryLabels", entryLabels );
        gui_e.onChange( entriesChange );

        return gui_e;
    }

    function entriesChange() {
        console.log("Selected entry");
    }

    /**
     * Set up the datgui controls on the basis of the loaded storm data
     */
    function setupDatGui() {

        var gui_storms;
        var gui_entries;
        years = stormFile.getYears();
        storms = stormFile.getStormsForYear(years[0]);
        stormLabels = stormFile.getStormLabels(storms);
        entryLabels = stormFile.getEntryLabels( storms[0] );

        var options = {};
        options.year = years[0];
        options.stormLabels = stormLabels[0];
        options.entryLabels = entryLabels[0];

        var gui_year = gfxScene.gui.add(options, "year", years ).onChange(function() {
            console.log("Changed year");
            gui_storms = addStormsGui( gui_storms, options, options.year );
        });

        gui_storms = addStormsGui( gui_storms, options, options.year );

        gui_entries = addEntriesGui( gui_entries, options, storms[0]);
    }

    /**
     * Called by the hurricane model to have the sample data rendered
     * In this case, the wind arrows and eye are already in existence
     * so we just update the location of the eye and set the direction
     * and scale of the arrows
     */
    function renderFunc ( eyex, eyeY, sampleData ) {

    }

    /**
     * Animate the scene and call rendering.
     */
    function animateScene() {

        // Tell the browser to call this function when page is visible
        requestAnimationFrame(animateScene);

        // tell the hurricane model to update itself and call back to render when it can
        //hurrModel.timeStep();

        // Map the 3D scene down to the 2D screen (render the frame)
        gfxScene.renderScene();
    }
</script>

</body>
</html>