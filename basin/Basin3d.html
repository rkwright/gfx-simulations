<!DOCTYPE html>
<html>
	<head>
		<!--
  			@author: rkwright@geofx.com
		-->
		<title>Basin 3D</title>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8"/>

		<!-- Set the viewport size to the screen size, so it will be displayed maximized, but unscaled. -->
		<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1"/>

		<!-- Include several libraries from THREE.js and the Scene class  -->
		<script src="../three-js/three.js" type="text/javascript"></script>
		<script src="../three-js/Detector.js" type="text/javascript"></script>
		<script src="../three-js/OrbitControls-Touch-Ortho.js" type="text/javascript"></script>
		<script src="../three-js/stats.js" type="text/javascript"></script>
        <script src="../gfx/gfx-scene.js" type="text/javascript"></script>
        <script src="../maze/Maze.js"></script>
        <script src="../maze/MazeRat.js"></script>
        <script src="Basin.js"></script>
	</head>
	<body style="margin:0;padding:0;border:0">
    <script type="text/javascript">
        var NCELLS = 32;
        var plane;
        var terrain = [];
        var basin;
        var planeMesh;

        var gfxScene = new GFX.Scene( {
            cameraPos : [10, 10, 10],
            axesHeight:10,
            controls:true,
            displayStats:true
        });


        initializeDemo();

        animateScene();

        /**
         * Initialize the Demo.
         */
        function initializeDemo() {

            var startTime = performance.now();

            basin = new BASIN.Basin(NCELLS);

            basin.construct();

            createTerrain( NCELLS );

            computeElevations( NCELLS );

            dumpTerrain( NCELLS );
            dumpCells( NCELLS );

            createPlaneGeometry( NCELLS );

            createPlaneMesh();

            renderStreams();

            var elapsed = (performance.now() - startTime)/1000.0;
            console.log("Basin complete! elapsed: " +  elapsed.toFixed(3)  );
        }

        /**
         * This creates the terrain array but sets elevation to -1 to indicate that
         * it is uninitialized.
         */
        function createTerrain( nCells ) {

            // first, create and populate the terrain array
            for ( var i = 0; i < nCells*2+1; i++ ) {
                terrain[i] = [];
                for ( var j = 0; j < nCells*2+1; j++ ) {
                    terrain[i][j] = new THREE.Vector3(i, -1, j);
                }
            }
        }

        /*
         * This creates the mesh comprised of nCells by nCells quad-patches.
         * Elevations are still all -1
         */
        function createPlaneGeometry( nCells ) {

            plane = new THREE.Geometry();

            for ( var i = 0; i < nCells*2; i += 2 ) {
                for ( var j = 0; j < nCells*2; j += 2 ) {
                    createQuadPatch( i, j );
                }
            }
        }

        /**
         * Walk the existing geometry and compute, for each quad-patch
         * the elevations of the vertices.
         */
        function computeElevations( nCells ) {

            for ( var i = 0; i < nCells; i++ ) {
                for ( var j = 0; j < nCells; j++ ) {
                    computeCellElevations( i, j );
                }
            }
        }

        /**
         *  Create the actual mesh from the geometry and some fakes material.
         */
        function createPlaneMesh()  {

            var wireMat = new THREE.MeshBasicMaterial({
                color: 0xccccff,
                wireframe: true, transparent: true, opacity: 0.25
            });
            var colorMat = new THREE.MeshPhongMaterial({
                color: 0x598527,
                side: THREE.DoubleSide
            });

            planeMesh = THREE.SceneUtils.createMultiMaterialObject(plane, [colorMat, wireMat]);

            // and add it to the scene
            gfxScene.add(planeMesh);
            planeMesh.position.set(-NCELLS, 0, -NCELLS)
        }

        /**
         * Compute the elevation of the 9 vertices that make up each quad-patch
         */
        function computeCellElevations( i, j ) {
            // get the cell for convenience and the terrain indices
            var bounds = basin.maze.cells[i * basin.maze.row + j];
            var cell = basin.geos[i][j];
            var it = i * 2 + 1;
            var jt = j * 2 + 1;
            // first set the center of the cell, which is already computed
            terrain[it][jt].y = cell.chanElev;

            // next, check each edge and see if this cell has a stream to the next
            // if so, simply interpolate between the two slopes
            computeStreamElev( bounds, cell, i, j );

            // now check the other interpolated points
            computeElevBounds( bounds, i, j );
        }

        /**
         * Compute the interpolated elevation of any streams entering or leaving the cell
         */
        function computeStreamElev ( bounds, cell, i, j ) {
            var it = i * 2 + 1 ;
            var jt = j * 2 + 1;
            var eI, eJ;

            if ((bounds & MAZE.SOUTH_BIT) === 0 ) {
                eI = Math.max(i + MAZE.YEdge[MAZE.SOUTH], 0);
                eJ = Math.max(j + MAZE.XEdge[MAZE.SOUTH], 0);
                terrain[it-1][jt].y = (cell.chanElev + basin.geos[eI][eJ].chanElev) / 2;
            }

            if ((bounds & MAZE.WEST_BIT) === 0 ) {
                eI = Math.max(i + MAZE.YEdge[MAZE.WEST], 0);
                eJ = Math.max(j + MAZE.XEdge[MAZE.WEST], 0);
                terrain[it][jt-1].y = (cell.chanElev + basin.geos[eI][eJ].chanElev) / 2;
            }

            if ((bounds & MAZE.NORTH_BIT) === 0 ) {
                eI = Math.max(i + MAZE.YEdge[MAZE.NORTH], 0);
                eJ = Math.max(j + MAZE.XEdge[MAZE.NORTH], 0);
                terrain[it+1][jt].y = (cell.chanElev + basin.geos[eI][eJ].chanElev) / 2;
            }

            if ((bounds & MAZE.EAST_BIT) === 0 ) {
                eI = Math.max(i + MAZE.YEdge[MAZE.EAST], 0);
                eJ = Math.max(j + MAZE.XEdge[MAZE.EAST], 0);
                terrain[it][jt+1].y = (cell.chanElev + basin.geos[eI][eJ].chanElev) / 2;
            }
        }

        /**
         *  Compute the interpolated elevation of each of the 8 points around the periphery of
         *  the cell.  Some, e.g. if there is a stream entering or exiting, will already be computed
         *  so they won't be -1 and can be skipped
         */
        function computeElevBounds ( bounds, i, j ) {
            var offset =
                [
                    { i: -1, j:  0 },   // south
                    { i: -1, j: -1 },
                    { i:  0, j: -1 },   // west
                    { i:  1, j: -1 },
                    { i:  1, j:  0 },   // north
                    { i:  1, j:  1 },
                    { i:  0, j:  1 },   // east
                    { i: -1, j:  1 }
                ];

            try {


            var slopes = [];
            var it,jt;
            var rowLim = basin.maze.row - 1;
            var colLim = basin.maze.col - 1;
            var tRowLim = terrain.length;
            var tColLim = terrain[0].length;
            var base = basin.geos[i][j].chanElev;

            for ( var n=0; n<8; n++ ) {
                it = i * 2 + offset[n].i + 1;
                jt = j * 2 + offset[n].j + 1;

                // if the current point is a stream, then obviously it's not an interfluve
                var bStream = ((bounds & MAZE.SOUTH_BIT) === 0 && n === 0 ) ||
                              ((bounds & MAZE.WEST_BIT) === 0 && n === 2 ) ||
                              ((bounds & MAZE.NORTH_BIT) === 0 && n === 4 ) ||
                              ((bounds & MAZE.EAST_BIT) === 0 && n === 6 );

                if (it >= 0 && it < tRowLim && jt >= 0 && jt < tColLim && !bStream)  {

                    switch (n) {
                        case 0:     // south
                            if (i !== 0 ) {
                                slopes.push(basin.geos[i - 1][j].chanSlope);
                            }
                            break;
                        case 1:     // southwest
                            if (i !== 0 && j !== 0) {
                                slopes.push(basin.geos[i - 1][j - 1].chanSlope);
                            }
                            if (j !== 0) {
                                slopes.push(basin.geos[i][j - 1].chanSlope);
                            }
                            if (i !== 0) {
                                slopes.push(basin.geos[i - 1][j].chanSlope);
                            }
                            break;
                        case 2:     // west
                            if (j !== 0 ) {
                                slopes.push(basin.geos[i][j - 1].chanSlope);
                            }
                            break;
                        case 3:     // northwest
                            if (i !== 0) {
                                slopes.push(basin.geos[i - 1][j].chanSlope);
                            }
                            if (i !== rowLim && j !== 0) {
                                slopes.push(basin.geos[i + 1][j - 1].chanSlope);
                            }
                            if (i !== rowLim) {
                                slopes.push(basin.geos[i + 1][j].chanSlope);
                            }
                            break;
                        case 4:     // north
                            if (i !== rowLim ) {
                                slopes.push(basin.geos[i + 1][j].chanSlope);
                            }
                            break;
                        case 5:     // northeast
                            if (i !== rowLim) {
                                slopes.push(basin.geos[i + 1][j].chanSlope);
                            }
                            if (j !== colLim) {
                                slopes.push(basin.geos[i][j + 1].chanSlope);
                            }
                            if (i !== rowLim && j !== colLim) {
                                slopes.push(basin.geos[i + 1][j + 1].chanSlope);
                            }
                            break;
                        case 6:     // east
                            if (j !== colLim ) {
                                slopes.push(basin.geos[i][j + 1].chanSlope);
                            }
                            break;
                        case 7:     // southeast
                            if (i !== rowLim) {
                                slopes.push(basin.geos[i + 1][j].chanSlope);
                            }
                            if (j !== colLim) {
                                slopes.push(basin.geos[i][j + 1].chanSlope);
                            }
                            if (i !== 0 && j !== colLim) {
                                slopes.push(basin.geos[i - 1][j + 1].chanSlope);
                            }
                            break;
                    }

                    slopes.push(basin.geos[i][j].chanSlope);

                    terrain[it][jt].y = Math.max( terrain[it][jt].y, interfluveHeight(slopes, base));
                    if (terrain[it][jt].y < 0)
                        debugger;
                }
            }
            }
            catch ( err ) {
                console.log("Bummer");
            }
        }

        function interfluveHeight ( slopes, base ) {
            var n = slopes.length;
            var h = 0;

            while (slopes.length > 0) {
                h = Math.max(h, slopes.pop());
            }

            return h * 2 + base;
        }

        /**
         *  Create the 8 triangles that comprise each quad-patch
         */
        function createQuadPatch( i, j ) {
            var vC = plane.vertices.length;

            // first pair of triangles
            plane.vertices.push( terrain[i][j] );
            plane.vertices.push( terrain[i][j+1] );
            plane.vertices.push( terrain[i+1][j+1] );
            plane.vertices.push( terrain[i+1][j] );

            plane.faces.push(new THREE.Face3(vC + 0, vC + 1, vC + 2));
            plane.faces.push(new THREE.Face3(vC + 0, vC + 2, vC + 3));

            // second pair of triangles
            vC = plane.vertices.length;
            plane.vertices.push( terrain[i][j+1] );
            plane.vertices.push( terrain[i][j+2] );
            plane.vertices.push( terrain[i+1][j+2] );
            plane.vertices.push( terrain[i+1][j+1] );

            plane.faces.push(new THREE.Face3(vC + 0, vC + 1, vC + 3));
            plane.faces.push(new THREE.Face3(vC + 1, vC + 2, vC + 3));

            // third pair of triangles
            vC = plane.vertices.length;
            plane.vertices.push( terrain[i+1][j+1] );
            plane.vertices.push( terrain[i+1][j+2] );
            plane.vertices.push( terrain[i+2][j+2] );
            plane.vertices.push( terrain[i+2][j+1] );

            plane.faces.push(new THREE.Face3(vC + 0, vC + 1, vC + 2));
            plane.faces.push(new THREE.Face3(vC + 0, vC + 2, vC + 3));

            // fourth pair of triangles
            vC = plane.vertices.length;
            plane.vertices.push( terrain[i+1][j] );
            plane.vertices.push( terrain[i+1][j+1] );
            plane.vertices.push( terrain[i+2][j+1] );
            plane.vertices.push( terrain[i+2][j] );

            plane.faces.push(new THREE.Face3(vC + 0, vC + 1, vC + 3));
            plane.faces.push(new THREE.Face3(vC + 1, vC + 2, vC + 3));
        }

        function renderStreams() {
            basin.rat.initSolveObj(0x80, false, renderStream);

            basin.rat.findSolution(-1, -1);
        }

        function renderStream( label, rat,  i,  j, nexi, nexj, pathlen, bsac ) {

            var material = new THREE.LineBasicMaterial({ color: 0x0000ff });

            var geometry = new THREE.Geometry();
            geometry.vertices.push(new THREE.Vector3(2 * i + 1 - NCELLS, 3, 2 * j + 1 - NCELLS));
            geometry.vertices.push(new THREE.Vector3(2 * nexi + 1-NCELLS, 3, 2 * nexj + 1 - NCELLS));

            var line = new THREE.Line(geometry, material);

            gfxScene.add(line);
        }

        function dumpTerrain ( nCells ) {

            for ( var i = 0; i < nCells * 2 + 1; i++ ) {

                    console.log(i.toFixed(0) + " : " + terrain[i][0].y.toFixed(3) + " " +  terrain[i][1].y.toFixed(3) + " " +
                        terrain[i][2].y.toFixed(3) + " " + terrain[i][3].y.toFixed(3) + " " + terrain[i][4].y.toFixed(3) + " " +
                        terrain[i][5].y.toFixed(3) + " " + terrain[i][6].y.toFixed(3) + " " + terrain[i][7].y.toFixed(3) + " " +
                        terrain[i][8].y.toFixed(3) );
            }

        }

        function dumpCells( nCells ) {

            for (var i = 0; i < nCells; i++ ) {

                console.log(i.toFixed(0) + " : " + basin.geos[i][0].chanElev.toFixed(3) + " " + basin.geos[i][1].chanElev.toFixed(3) + " " +
                    basin.geos[i][2].chanElev.toFixed(3) + " " + basin.geos[i][3].chanElev.toFixed(3) );
            }
        }

        /**
         * Animate the scene and call rendering.
         */
        function animateScene() {

            requestAnimationFrame(animateScene);

            gfxScene.renderScene();
        }

    </script>

	</body>
</html>
