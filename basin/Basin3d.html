<!DOCTYPE html>
<html>
	<head>
		<!--
  			@author: rkwright@geofx.com
		-->
		<title>Basin 3D</title>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8"/>

		<!-- Set the viewport size to the screen size, so it will be displayed maximized, but unscaled. -->
		<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1"/>

		<!-- Include several libraries from THREE.js and the Scene class  -->
		<script src="../three-js/three.js" type="text/javascript"></script>
		<script src="../three-js/Detector.js" type="text/javascript"></script>
		<script src="../three-js/OrbitControls-Touch-Ortho.js" type="text/javascript"></script>
		<script src="../three-js/stats.js" type="text/javascript"></script>
        <script src="../gfx/gfx-scene.js" type="text/javascript"></script>


	</head>
	<body>
    <script type="text/javascript">
        var NCELLS = 16;
        var plane;
        var terrain = [];
        var planeMesh;

        // allocate the Scene object, request orbitControls, some of 3D axes 10 units high and the stats
        var gfxScene = new GFX.Scene( {
            cameraPos : [10, 20, 40],
            axesHeight:10,
            controls:true,
            displayStats:true
        });

        // then initialize our demo's stuff
        initializeDemo();

        // Animate the scene
        animateScene();

        /**
         * Initialize the Demo.
         */
        function initializeDemo() {

            createPlane();
        }

        function createPlane() {

            var i,j;
            // first, create the two-dimensional array of Vector3 that will be vertices
            for ( i = 0; i < NCELLS*2+1; i++ ) {
                terrain[i] = [];

                for ( j = 0; j < NCELLS*2+1; j++ ) {
                    terrain[i][j] = new THREE.Vector3(j, Math.random()*2, i);
                }
            }
            for ( i = 0; i < NCELLS*2+1; i++ ) {

                for ( j = 0; j < NCELLS*2+1; j++ ) {
                    console.log(" i,j: " + i.toFixed(0) + "," +  j.toFixed(0) + ": " +
                        terrain[i][j].x.toFixed(2) + " " + terrain[i][j].y.toFixed(2) + " " + terrain[i][j].z.toFixed(2));
                }
            }

            plane = new THREE.Geometry();

            for ( i = 0; i < NCELLS*2; i += 2 ) {

                for ( j = 0; j < NCELLS*2; j += 2 ) {

                    createQuadPatch( i, j);
                }
            }

            // re-compute the normals for both the faces and vertexes
            plane.computeFaceNormals();
            plane.computeVertexNormals();

            plane.computeBoundingSphere();

            var wireMaterial = new THREE.MeshBasicMaterial( { color: 0xccccff, wireframe: true, transparent: true, opacity:1 } );
            var colorMaterial = new THREE.MeshPhongMaterial( { color: 0x000080, side:THREE.DoubleSide } );

            planeMesh = THREE.SceneUtils.createMultiMaterialObject( plane, [ colorMaterial, wireMaterial ] );

            console.log("Verticies:");
            for ( var k=0; k<plane.vertices.length; k++ ) {
                console.log("k: " + k.toFixed(0) + " x,y,z: " + plane.vertices[k].x.toFixed(3) + " " + plane.vertices[k].y.toFixed(3) + " " + plane.vertices[k].z.toFixed(3));
            }

            console.log("Faces:");
            for ( k=0; k<plane.faces.length; k++ ) {
                console.log("k: " + k.toFixed(0) + " x,y,z: " + plane.faces[k].a.toFixed(0) + " " + plane.faces[k].b.toFixed(0) + " " + plane.faces[k].c.toFixed(0));
            }
            // and add it to the scene
            gfxScene.add(planeMesh);
            planeMesh.position.set(-NCELLS, 0, -NCELLS)
        }

        function createQuadPatch( i, j ) {
            var vC = plane.vertices.length;

            plane.vertices.push( terrain[i][j] );
            plane.vertices.push( terrain[i][j+1] );
            plane.vertices.push( terrain[i+1][j+1] );
            plane.vertices.push( terrain[i+1][j] );

            console.log("     i,j: " + i.toFixed(0) + "," +  j.toFixed(0) + ": " +
                terrain[i][j].x.toFixed(2) + " " + terrain[i][j].y.toFixed(2) + " " + terrain[i][j].z.toFixed(2));
            console.log("   i,j+1: " + i.toFixed(0) + "," +  j.toFixed(0) + ": " +
                terrain[i][j+1].x.toFixed(2) + " " + terrain[i][j+1].y.toFixed(2) + " " + terrain[i][j+1].z.toFixed(2));
            console.log(" i+1,j+1: " + i.toFixed(0) + "," +  j.toFixed(0) + ": " +
                terrain[i+1][j+1].x.toFixed(2) + " " + terrain[i+1][j+1].y.toFixed(2) + " " + terrain[i+1][j+1].z.toFixed(2));
            console.log(" i+1,j: " + i.toFixed(0) + "," +  j.toFixed(0) + ": " +
                terrain[i+1][j].x.toFixed(2) + " " + terrain[i+1][j].y.toFixed(2) + " " + terrain[i+1][j].z.toFixed(2));

            plane.faces.push(new THREE.Face3(vC + 0, vC + 1, vC + 2));
            plane.faces.push(new THREE.Face3(vC + 0, vC + 2, vC + 3));

            // second pair of triangles
            vC = plane.vertices.length;
            plane.vertices.push( terrain[i][j+1] );
            plane.vertices.push( terrain[i][j+2] );
            plane.vertices.push( terrain[i+1][j+2] );
            plane.vertices.push( terrain[i+1][j+1] );
            plane.faces.push(new THREE.Face3(vC + 0, vC + 1, vC + 3));
            plane.faces.push(new THREE.Face3(vC + 1, vC + 2, vC + 3));

            // third pair of triangles
            vC = plane.vertices.length;
            plane.vertices.push( terrain[i+1][j+1] );
            plane.vertices.push( terrain[i+1][j+2] );
            plane.vertices.push( terrain[i+2][j+2] );
            plane.vertices.push( terrain[i+2][j+1] );
            plane.faces.push(new THREE.Face3(vC + 0, vC + 1, vC + 2));
            plane.faces.push(new THREE.Face3(vC + 0, vC + 2, vC + 3));

            // fourth pair of triangles
            vC = plane.vertices.length;
            plane.vertices.push( terrain[i+1][j] );
            plane.vertices.push( terrain[i+1][j+1] );
            plane.vertices.push( terrain[i+2][j+1] );
            plane.vertices.push( terrain[i+2][j] );
            plane.faces.push(new THREE.Face3(vC + 0, vC + 1, vC + 3));
            plane.faces.push(new THREE.Face3(vC + 1, vC + 2, vC + 3));
        }

        /**
         * Animate the scene and call rendering.
         */
        function animateScene() {

            // Tell the browser to call this function when page is visible
            requestAnimationFrame(animateScene);

            gfxScene.renderScene();
        };

    </script>

	</body>
</html>
